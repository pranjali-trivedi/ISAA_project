<?php


require_once 'Crypt/DiffieHellman/Math.php';

class Crypt_DiffieHellman
{

    private $_prime = null;

    private $_generator = null;

    /**
     * A private number set by the local user. It's optional and will
     * be generated if not set.
     *
     * @var string
     */
    private $_privateKey = null;

    private $_math = null;

    /**
     * The public key generated by this instance after calling generateKeys().
     *
     * @var string
     */
    private $_publicKey = null;

    /**
     * The shared secret key resulting from a completed Diffie Hellman
     * exchange
     *
     * @var string
     */
    private $_secretKey = null;

    /**
     * Constants; used to define inputs or outputs as binary or big numbers.
     * Binary form is often used as the exchange form for public keys.
     */
    const BINARY = 'binary';
    const NUMBER = 'number';
    const BTWOC  = 'btwoc';

    /**
     * Constructor; if set construct the object using the parameter array to
     * set values for Prime, Generator and Private.
     * If a Private Key is not set, one will be generated at random.
     *
     * @param string|integer $prime
     * @param string|integer $generator
     * @param string|integer $privateKey
     * @param string $privateKeyType
     * @param string $mathExtension
     */
    public function __construct($prime, $generator, $privateKey = null, $privateKeyType = null, $mathExtension = null)
    {
        $this->setPrime($prime);
        $this->setGenerator($generator);
        if (!is_null($privateKey)) {
            if (is_null($privateKeyType)) {
                $privateKeyType = self::NUMBER;
            }
            $this->setPrivateKey($privateKey, $privateKeyType);
        }
        $this->setBigIntegerMath($mathExtension);
    }

    /**
     * Generate own public key. If a private number has not already been
     * set, one will be generated at this stage.
     *
     * @return Crypt_DiffieHellman
     */
    public function generateKeys()
    {
        $this->_publicKey = $this->_math->powmod($this->getGenerator(), $this->getPrivateKey(), $this->getPrime());
        return $this;
    }

    /**
     * Returns own public key for communication to the second party to this
     * transaction.
     *
     * @param string $type
     * @return string
     */
    public function getPublicKey($type = self::NUMBER)
    {
        if (is_null($this->_publicKey)) {
            require_once 'Crypt/DiffieHellman/Exception.php';
            throw new Crypt_DiffieHellman_Exception('A public key has not yet been generated using a prior call to generateKeys()');
        }
        if ($type == self::BINARY) {
            return $this->_math->toBinary($this->_publicKey);
        } elseif ($type == self::BTWOC) {
            return $this->_math->btwoc($this->_math->toBinary($this->_publicKey));
        }
        return $this->_publicKey;
    }

    /**
     * Compute the shared secret key based on the public key received from the
     * the second party to this transaction. This should agree to the secret
     * key the second party computes on our own public key.
     * Once in agreement, the key is known to only to both parties.
     * By default, the function expects the public key to be in binary form
     * which is the typical format when being transmitted.
     *
     * @param string $publicKey
     * @param string $type
     * @return void
     */
    public function computeSecretKey($publicKey, $type = self::NUMBER)
    {
        if ($type == self::BINARY) {
            $publicKey = $this->_math->fromBinary($publicKey);
        }
        if (!preg_match("/^\d+$/", $publicKey)) {
            require_once('Crypt/DiffieHellman/Exception.php');
            throw new Crypt_DiffieHellman_Exception('invalid parameter; not a positive natural number');
        }
        $this->_secretKey = $this->_math->powmod($publicKey, $this->getPrivateKey(), $this->getPrime());
        return $this;
    }

    /**
     * Return the computed shared secret key from the DiffieHellman transaction
     *
     * @param string $type
     * @return string
     */
    public function getSharedSecretKey($type = self::NUMBER)
    {
        if (!isset($this->_secretKey)) {
            require_once('Crypt/DiffieHellman/Exception.php');
            throw new Crypt_DiffieHellman_Exception('A secret key has not yet been computed; call computeSecretKey()');
        }
        if ($type == self::BINARY) {
            return $this->_math->toBinary($this->_secretKey);
        } elseif ($type == self::BTWOC) {
            return $this->_math->btwoc($this->_math->toBinary($this->_secretKey));
        }
        return $this->_secretKey;
    }

    /**
     * Setter for the value of the prime number
     *
     * @param string $number
     * @return Crypt_DiffieHellman
     */
    public function setPrime($number)
    {
        if (!preg_match("/^\d+$/", $number) || $number < 11) {
            require_once('Crypt/DiffieHellman/Exception.php');
            throw new Crypt_DiffieHellman_Exception('invalid parameter; not a positive natural number or too small: should be a large natural number prime');
        }
        $this->_prime = (string) $number;
        return $this;
    }

    /**
     * Getter for the value of the prime number
     *
     * @param string $type
     * @return string
     */
    public function getPrime($type = self::NUMBER)
    {
        if (!isset($this->_prime)) {
            require_once('Crypt/DiffieHellman/Exception.php');
            throw new Crypt_DiffieHellman_Exception('No prime number has been set');
        }

        if ($type == self::NUMBER) {
            return $this->_prime;
        } else if ($type == self::BTWOC) {
            return $this->_math->btwoc($this->_math->toBinary($this->_prime));
        }

        return $this->_math->toBinary($this->_prime);
    }

    /**
     * Setter for the value of the generator number
     *
     * @param string $number
     * @return Crypt_DiffieHellman
     */
    public function setGenerator($number)
    {
        if (!preg_match("/^\d+$/", $number) || $number < 2) {
            require_once('Crypt/DiffieHellman/Exception.php');
            throw new Crypt_DiffieHellman_Exception('invalid parameter; not a positive natural number greater than 1');
        }
        $this->_generator = (string) $number;
        return $this;
    }

    /**
     * Getter for the value of the generator number
     *
     * @param string $type
     * @return string
     */
    public function getGenerator($type = self::NUMBER)
    {
        if (!isset($this->_generator)) {
            require_once('Crypt/DiffieHellman/Exception.php');
            throw new Crypt_DiffieHellman_Exception('No generator number has been set');
        }
        if ($type == self::NUMBER) {
            return $this->_generator;
        } else if ($type == self::BTWOC) {
            return $this->_math->btwoc($this->_math->toBinary($this->_generator));
        }
        return $this->_math->toBinary($this->_generator);
    }

    public function setPrivateKey($number, $type = self::NUMBER)
    {
        if ($type == self::BINARY) {
            $number = $this->_math->fromBinary($number);
        }
        if (!preg_match("/^\d+$/", $number)) {
            require_once('Crypt/DiffieHellman/Exception.php');
            throw new Crypt_DiffieHellman_Exception('invalid parameter; not a positive natural number');
        }
        $this->_privateKey = (string) $number;
        return $this;
    }

    public function getPrivateKey($type = self::NUMBER)
    {
        if (!isset($this->_privateKey)) {
            $this->setPrivateKey($this->_generatePrivateKey(), self::BINARY);
        }
        if ($type == self::BINARY) {
            return $this->_math->toBinary($this->_privateKey);
        } elseif ($type == self::BTWOC) {
            return $this->_math->btwoc($this->_math->toBinary($this->_privateKey));
        }
        return $this->_privateKey;
    }
     *
     * @param string $extension
     * @return void
     */
    public function setBigIntegerMath($extension = null)
    {
        $this->_math = new Crypt_DiffieHellman_Math($extension);
    }

    /**
     * In the event a private number/key has not been set by the user,
     * generate one at random.
     *
     * @return string
     */
    protected function _generatePrivateKey()
    {
        $rand = $this->_math->rand($this->getGenerator(), $this->getPrime());
        return $rand;
    }

}
